<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta name="generator" content="jemdoc, see http://jemdoc.jaboc.net/" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link rel="stylesheet" href="jemdoc.css" type="text/css" />
<title>Blogs</title>
<!-- MathJax -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
	  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<!-- End MathJax -->
</head>
<body>
<table summary="Table for page layout." id="tlayout">
<tr valign="top">
<td id="layout-menu">
<div class="menu-item"><a href="index.html">home</a></div>
<div class="menu-item"><a href="blogs.html">blogs</a></div>
<div class="menu-item"><a href="my_resume.pdf">resume</a></div>
<div class="menu-item"><a href="random.html">random</a></div>
<div class="menu-item"><a href="archives.html">archives</a></div>
</td>
<td id="layout-content">
<div id="toptitle">
<h1>Blogs</h1>
<div id="subtitle"></div>
</div>
<h2>Arcball Camera System Using Euler Angles</h2>
<p>
In this modified version of <tt>jemdoc</tt>, a LaTeX equation block can be typed in as</p>
<p style="text-align:center">
\[
\nabla \cdot \mathbf{D} = \rho_f\\
\nabla \cdot \mathbf{B} = 0,\\
\nabla \times \mathbf{E} = -\frac{\partial\mathbf{B}}{\partial t}\\
\nabla \times \mathbf{H} = \mathbf{J}_f - \frac{\partial\mathbf{D}}{\partial t}.
\]
</p><p>
You can also align equations using LaTeX's <tt>aligned</tt> block:</p>
<p style="text-align:center">
\[
\begin{aligned}
\nabla \cdot \mathbf{D} &amp;= \rho_f\\
\nabla \cdot \mathbf{B} &amp;= 0\\
\nabla \times \mathbf{E} &amp;= -\frac{\partial\mathbf{B}}{\partial t}\\
\nabla \times \mathbf{H} &amp;= \mathbf{J}_f - \frac{\partial\mathbf{D}}{\partial t}.
\end{aligned}
\]
</p><p>
To number the equation block, wrap the equations with LaTeX's <tt>equation</tt> block:</p>
<p style="text-align:center">
\[
\begin{equation}
\begin{aligned}
\nabla \cdot \mathbf{D} &amp;= \rho_f\\
\nabla \cdot \mathbf{B} &amp;= 0\\
\nabla \times \mathbf{E} &amp;= -\frac{\partial\mathbf{B}}{\partial t}\\
\nabla \times \mathbf{H} &amp;= \mathbf{J}_f - \frac{\partial\mathbf{D}}{\partial t}.
\end{aligned}
\end{equation}
\]
</p><p>
Instead, you can use LaTeX's <tt>align</tt> (not <tt>aligned</tt>) block to number the individual equations:</p>
<p style="text-align:center">
\[
\begin{align}
\nabla \cdot \mathbf{D} &amp;= \rho_f\label{eq:D}\\
\nabla \cdot \mathbf{B} &amp;= 0\label{eq:B}\\
\nabla \times \mathbf{E} &amp;= -\frac{\partial\mathbf{B}}{\partial t}\label{eq:E}\\
\nabla \times \mathbf{H} &amp;= \mathbf{J}_f - \frac{\partial\mathbf{D}}{\partial t}\label{eq:H}
\end{align}
\]
</p><p>
You can also type inline equations as \(A x = b\).  Referencing equations is done as Eqs.&nbsp;\(\eqref{eq:E}\) and \(\eqref{eq:H}\).

</p>
<div class="codeblock">
<div class="blockcontent"><pre>
#pragma once

#include &lt;glad/glad.h&gt;

#include &lt;glm/glm.hpp&gt;
#include &lt;glm/gtc/matrix_transform.hpp&gt;
#include &lt;glm/gtx/rotate_vector.hpp&gt;
#include &lt;glm/gtc/quaternion.hpp&gt;
#include &lt;glm/gtx/quaternion.hpp&gt;
#include &lt;glm/ext/quaternion_transform.hpp&gt;
#include "mouse_listener.h"

#define PI 3.14159265358979323846
#define TAU 2*PI
#define MAX(x, y) (((x) &gt; (y)) ? (x) : (y))
#define MIN(x, y) (((x) &lt; (y)) ? (x) : (y))

typedef glm::vec3 Vec3;
typedef glm::quat Quat;

// Defines several possible options for camera movement. Used as abstraction to stay away from window-system specific input methods
enum Camera_Movement {
	FORWARD,
	BACKWARD,
	LEFT,
	RIGHT
};

enum Camera_State {
	CAM_FIXED,
	CAM_FREE
};

// Default camera values
const float PITCH = 0.0f;
const float YAW = 0.0f;
const float SPEED = 5.0f;
const float SENSITIVITY = 0.005f;
const float ZOOM = 1.0f;

// An abstract camera class that processes input and calculates the corresponding Euler Angles, Vectors and Matrices for use in OpenGL
class ArcBallCamera
{
public:
	// Camera Attributes
	Camera_State cameraState;
	float Pitch;
	float Yaw;
	// Camera options
	float MovementSpeed;
	float MouseSensitivity;
	float ScrollSensitivity;
	float Zoom;
	glm::vec2 center;

	Quat qstart;
	Quat qnow;
	Vec3 p0, p1;
	ArcBallCamera(
		float pitch = PITCH, float yaw = YAW
		) : MovementSpeed(SPEED), MouseSensitivity(SENSITIVITY), ScrollSensitivity(SENSITIVITY*30), Zoom(ZOOM)
	{
		Pitch = pitch;
		Yaw = yaw;
		p0 = Vec3(0.0f, 0.0f, 1.0f);
		//axis of rotation at 0 pitch and yaw: y up
		qstart.x = 0.0f;
		qstart.y = 1.0f;
		qstart.z = 0.0f;
		qstart.w = 0.0f;
		qnow = qstart;
		cameraState = CAM_FREE;
	}

	// Returns the view matrix calculated using Euler Angles and the LookAt Matrix
	glm::mat4 GetViewMatrix()
	{
		auto model = GetModelMatrix();
		return glm::lookAt(glm::vec3(0.0f, 0.0f, 1.0f), Vec3(0.0f, 0.0f, 0.0f), Vec3(0.0f, 1.0f, 0.0f))*glm::inverse(model);
	}

	void rotateTo(float dstYaw, float dstPitch)
	{
		if (cameraState == CAM_FIXED) return;
		Pitch = dstPitch;
		Yaw = dstYaw;
	}

	glm::vec3 getPosition()
	{
		return Vec3(
			sinf(PI/2 - Pitch)*sinf(Yaw),
			-cosf(PI/2 - Pitch),
			sinf(PI/2 - Pitch)*cosf(Yaw)
		);
	}

	void setScreenCenter(int scrW, int scrH) {
		center.x = float(scrW)/2;
		center.y = float(scrH)/2;
	}

	// Processes input received from any keyboard-like input system. Accepts input parameter in the form of camera defined ENUM (to abstract it from windowing systems)
	void ProcessKeyboard(Camera_Movement direction, float deltaTime)
	{
		if (cameraState == CAM_FIXED) return;
		float ang_disp = MovementSpeed * deltaTime;
		if (direction == FORWARD)
			Pitch -= ang_disp;
		if (direction == BACKWARD)
			Pitch += ang_disp;
		if (direction == LEFT)
			Yaw += ang_disp;
		if (direction == RIGHT)
			Yaw -= ang_disp;
	}

	// Processes input received from a mouse input system. Expects the offset value in both the x and y direction.
	void ProcessMouseMovement(const float xpos,const float ypos)
	{
		if (cameraState == CAM_FIXED) return;

		/*xoffset *= MouseSensitivity;
		yoffset *= MouseSensitivity;

		Yaw -= xoffset;
		Pitch += yoffset;*/


		computeMouseOnArcBall(xpos, ypos);

		auto pcross = glm::cross(p1, p0);
		//pcross *= 0.2;

		//p0 = p1;


		//PRINT3F(p1.x, p1.y, p1.z);
		Quat q;
		q.x = pcross.x;
		q.y = pcross.y;
		q.z = pcross.z;
		q.w = glm::dot(p0, p1);
		q = glm::normalize(q);
		//PRINT3F(q.x, q.y, q.z);
		qnow = q*qnow;

		p0 = p1;
	}

	void computeMouseOnArcBall(const float xpos, const float ypos) {
		auto radius = MAX(center.x, center.y);
		//printf("rad: %.2f\n", radius);
		//PRINT2F(xpos, ypos);
		/*p1.x = (xpos - center.x) / radius;
		p1.y = (center.y - ypos) / radius;*/

		p1.x = (xpos - center.x) / radius;
		p1.y = (center.y - ypos) / radius;
		//printf("\n");

		auto r = p1.x*p1.x + p1.y*p1.y;
		if (r &gt; 1.0) {
			auto s = 1.0 / sqrt(r);
			p1 *= s;
			p1.z = 0.0f;
		}
		else {
			p1.z = sqrt(1.0 - r);
		}
	}

	// Processes input received from a mouse scroll-wheel event. Only requires input on the vertical wheel-axis
	void ProcessMouseScroll(float yoffset)
	{
		//if (cameraState == CAM_FIXED) return;
		Zoom -= ScrollSensitivity*yoffset;
		if (Zoom &lt; 0.2f) Zoom = 0.2f;
		if (Zoom &gt; 3.0f) Zoom = 3.0;
		//printf("Zoom:%.2f\n", Zoom);
	}

private:

	glm::mat4 GetModelMatrix()
	{
		glm::mat4 model = glm::mat4(1.0f);
		//model = glm::scale(model, Vec3(Zoom));
		/*model = glm::rotate(model, Yaw, Vec3(0.0f, 1.0f, 0.0f));
		model = glm::rotate(model, Pitch, Vec3(1.0f, 0.0f, 0.0f));*/
		model = glm::scale(model, Vec3(Zoom));
		model = glm::toMat4(qnow)*model;
		return model;
	}

	glm::quat euler2quat_r(glm::vec3 eangles) {
		glm::quat qPitch = glm::angleAxis(eangles[0], glm::vec3(1, 0, 0));
		glm::quat qYaw = glm::angleAxis(eangles[1], glm::vec3(0, 1, 0));
		glm::quat qRoll = glm::angleAxis(eangles[2], glm::vec3(0, 0, 1));
		return qYaw *qPitch * qRoll;
	}

	float get_fixed_rotation_angle_from_2_vector(const glm::vec3&amp; u, const glm::vec3&amp; v)
	{
		return acos(dot(u, v) / glm::length(u) / glm::length(v));
	}

	glm::quat euler2quat_d(glm::vec3 eangles) {
		glm::radians(eangles);
		glm::quat qPitch = glm::angleAxis(eangles[0], glm::vec3(1, 0, 0));
		glm::quat qYaw = glm::angleAxis(eangles[1], glm::vec3(0, 1, 0));
		glm::quat qRoll = glm::angleAxis(eangles[2], glm::vec3(0, 0, 1));
		return qYaw *qPitch * qRoll;
	}

	glm::quat euler2quat_r(float pitch, float yaw, float roll) {
		glm::quat qPitch = glm::angleAxis(pitch, glm::vec3(1, 0, 0));
		glm::quat qYaw = glm::angleAxis(yaw, glm::vec3(0, 1, 0));
		glm::quat qRoll = glm::angleAxis(roll, glm::vec3(0, 0, 1));
		return qYaw *qPitch * qRoll;
	}

	glm::quat euler2quat_d(float pitch, float yaw, float roll) {
		pitch = glm::radians(pitch);
		yaw = glm::radians(yaw);
		roll = glm::radians(roll);
		glm::quat qPitch = glm::angleAxis(pitch, glm::vec3(1, 0, 0));
		glm::quat qYaw = glm::angleAxis(yaw, glm::vec3(0, 1, 0));
		glm::quat qRoll = glm::angleAxis(roll, glm::vec3(0, 0, 1));
		return qYaw *qPitch * qRoll;
	}
};
</pre></div></div>
</td>
</tr>
</table>
</body>
</html>
